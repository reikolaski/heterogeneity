using .Rouwenhorst_method, Interpolations, Plots, LaTeXStrings, DataFrames, CSV, Distributions, Random

default(fontfamily="Computer Modern", framestyle=:box, label=nothing, grid=false, legendfontsize=10)
scalefontsizes(1)

function EGM_finite_horizon(params; N=5, N_a=2500)
    """
    Compute optimal policy functions using the endogenous grid method.

    Inputs
    ------
        params: parameters of the modul
        N: number of income states
        N_a: number of points on the asset grid

    Outputs
    -------
        c: optimal consumption policy
        a: optimal savings policy
        G_a: asset grid
        G_y: income grid
        Pi: income transition matrix
    """

    # Unpack parameters, discretize income space, and define some useful functions
    phi, beta, Rf, gamma, a_min, rho, sigma, age_profile = params
    y_grid, Pi = Rouwenhorst(rho, sigma, N)
    T = length(age_profile)

    u(c) = c^(1 - gamma) / (1 - gamma)
    u_prime(c) = c^(-gamma)
    u_prime_inv(B) = B.^(-1 / gamma)

    # Define (tomorrow's) asset grid and income grid. Following Kindermann and Krueger (2018), 
    # define asset grid such that there are more points near the borrowing threshold. Note that
    # income grid is a discretization of the stochastic part of income, excluding the age 
    # dependent component.
    G_a  = [a_min + 1e6 * ((1 + 0.01)^(i - 1) - 1) / ((1 + 0.01)^(N_a-1) - 1) for i in 1:N_a] 
    G_y = exp.(y_grid)

    # Initialize policy functions
    a = zeros(length(G_a), length(G_y), T)
    c = zeros(length(G_a), length(G_y), T)

    # Consume all wealth in period T + nonworking life
    c[:, :, T] = Rf * G_a .+ age_profile[T] .* G_y'
    a[:, :, T] .= 0

    # Account for agents' need for funds at end of working life
    adj = phi

    # Solve backward given optimal behavior next period
    for t in T-1:-1:1
        c_hat = zeros(length(G_a), length(G_y))
        a_star = zeros(length(G_a), length(G_y))

        # Given a given asset level tomorrow + income shock today, compute the value of consumption that
        # satisfies the Euler equaion, then use budget constraint to solve for implied assets today.
        for (i, a) in enumerate(G_a)
            for (j, y) in enumerate(G_y)
                c_hat[i, j] = u_prime_inv(adj * beta * Rf * Pi[j, :]' * u_prime.(c[i, :, t+1]))
                a_star[i, j] = (c_hat[i, j] + a - age_profile[t] * y) / Rf
            end
        end
        ## or use:
        # c_hat = c_hat.((beta .* Rf .* Pi * u_prime.(c_star[:, :, t+1]'))')
        # Use budget constraint to solve for optimal savings policy
        # a_star[:, :] = (c_hat .+ G_a .- age_profile[t] .* G_y') / Rf

        # Interpolate or use budget constraint (depending on asset level) to get consumption policy
        a_star_min = a_star[1, :]
        for (j, y) in enumerate(G_y)
            # Euler equation determines consumption
            interp = LinearInterpolation(a_star[:, j], c_hat[:, j], extrapolation_bc=Line())
            c[:, j, t] = interp.(G_a)

            # Borrowing constraint determines consumption
            c[G_a .< a_star_min[j], j, t] = Rf .* G_a[G_a .< a_star_min[j]] .+ age_profile[t] * y .- a_min

            # Optimal savings policy
            a[:, j, t] = Rf .* G_a .+ age_profile[t] * y - c[:, j, t]
        end
        adj = 1
    end

    return c, a, G_a, G_y, Pi
end

function simulate_income_path(G_y, Pi, age_profile; type::String="constant", init=1, seed=123)
    """
    Simulate lifecycle income profile.

    Inputs
    ------
        G_y: income grid
        Pi: income transition matrix
        age_profile: age dependent component of income
        type: "constant" or "stochastic"
        init: initial income states
        seed: random seed

    Outputs
    -------
        income_path: lifecycle income over T periods
        index_path: index of lifecycle income over T periods
    """

    Random.seed!(seed)
    T = length(age_profile)

    if type == "constant"
        index_path = init * ones(Int8, T)
        income_path = G_y[index_path] .* age_profile
        return income_path, index_path

    elseif type == "stochastic"
        index_path = zeros(Int8, T)
        
        i = init
        for t in 1:T
            index_path[t] = i
            transition_probabilities = Pi[i, :]
            cumulative_transition_probabilities = cumsum(transition_probabilities)
            unif = rand(Uniform(0, 1))
            i = findfirst(x -> x > unif, cumulative_transition_probabilities)
        end
        income_path = G_y[index_path] .* age_profile
        return income_path, index_path
    end
end

function simulate_lifecycle_path(c, a, G_a, G_y, Pi, age_profile, Rf; initial_assets=0, type::String="constant", init=1, seed=123)
    """
    Simulate lifecycle income, consumption, savings, and wealth paths.

    Inputs
    ------
        c: optimal consumption policy
        a: optimal savings policy
        G_y: income grid
        Pi: income transition matrix
        age_profile: age dependent component of income
        Rf: riskfree gross interest rate
        type: "constant" or "stochastic"
        init: initial income states
        seed: random seed

    Outputs
    -------
        income_path: lifecycle income over T periods
        index_path: index of lifecycle income over T periods
    """

    T = length(age_profile)
    income_path, index_path = simulate_income_path(G_y, Pi, age_profile, type=type, init=init, seed=seed)
    wealth_path = zeros(T)
    consumption_path = zeros(T)
    savings_path = zeros(T)

    for t in 1:T
        wealth_path[t] = Rf * initial_assets + income_path[t]
        consumption_path[t] = c[argmin(abs.(G_a .- initial_assets)), index_path[t], t]
        savings_path[t] = a[argmin(abs.(G_a .- initial_assets)), index_path[t], t]
        initial_assets = savings_path[t]
    end

    return wealth_path, consumption_path, savings_path, income_path
end

# Set parameters
beta = 0.98
Rf = 1.02
rho = 0.985
sigma = sqrt(0.0346)
a_min = 0
gamma = 5
age_profile = DataFrame(CSV.File("data/age_profile.csv")).a
T = length(age_profile)
age = range(1+24, T+24)

# No bequest/savings motive
phi = 1
params = phi, beta, Rf, gamma, a_min, rho, sigma, age_profile
c, a, G_a, G_y, Pi = EGM_finite_horizon(params)
wealth_path, consumption_path, savings_path, income_path = simulate_lifecycle_path(c, a, G_a, G_y, Pi, age_profile, Rf, initial_assets=0, type="constant", init=3)
plot(age, savings_path / 1000, label="savings", 
     xlabel="Age",
     ylabel="Dollars (Thousands)",
     xticks=25:5:60,
     legend=:best)
plot!(age, consumption_path / 1000, label="consumption")
plot!(age, income_path / 1000, label="income")
plot!(age, wealth_path / 1000, label="wealth")
savefig("plots/lifcycle-median_income-no_bequest.pdf")

# Calibrate phi to match average (median?????) net worth at age 60 in SCF
median_wealth_age_60 = 0
SCF_median_wealth_age_60 = 188010.0
phi_low = 1
phi_high = 10000
maxiter = 100
iter = 1
while abs(median_wealth_age_60 - SCF_median_wealth_age_60) > 10 && iter <= maxiter
    phi = (phi_low + phi_high) / 2
    params = phi, beta, Rf, gamma, a_min, rho, sigma, age_profile
    c, a, G_a, G_y, Pi = EGM_finite_horizon(params)
    wealth_path, consumption_path, savings_path, income_path = simulate_lifecycle_path(c, a, G_a, G_y, Pi, age_profile, Rf, initial_assets=0, type="constant", init=3)
    median_wealth_age_60 = wealth_path[end]
    if median_wealth_age_60 < SCF_median_wealth_age_60
        phi_low = phi
    else
        phi_high = phi
    end
    iter += 1
end

plot(range(1+24, T+24-1), savings_path[1:end-1] / 1000, label="savings", 
     xlabel="Age",
     ylabel="Dollars (Thousands)",
     xticks=25:5:60,
     legend=:best)
plot!(range(1+24, T+24-1), consumption_path[1:end-1] / 1000, label="consumption")
plot!(range(1+24, T+24), income_path[1:end] / 1000, label="income")
plot!(range(1+24, T+24), wealth_path[1:end] / 1000, label="wealth")
savefig("plots/lifcycle-median_income-matching_age60_net_worth.pdf")
